

### 方案设计：一个名为 "Kotoba Vault (Local)" 的纯本地Flashcard应用

**核心理念：** 无需网络、无需账户、数据100%私有、体验媲美原生应用。

---

### 1. 技术架构 (Technical Architecture)

整个应用就是一个**高度优化的静态网站**，但具备了原生应用的能力。

*   **技术栈 (依然轻量)：**
    *   **框架 (Framework):** **SvelteKit**。SvelteKit是Svelte的官方应用框架，它内置了对PWA、离线支持和文件路由的优秀支持，是这个场景下的完美选择。
    *   **样式 (Styling):** 纯CSS或Tailwind CSS（如果希望快速构建UI）。
    *   **打包工具 (Bundler):** Vite (SvelteKit已集成)。
    *   **数据库 (Database):** **IndexedDB**。这是浏览器提供的一个功能强大的本地“数据库”，可以储存大量的结构化数据（我们的JSON卡片），并且支持索引和事务，远比LocalStorage强大。我们会使用一个名为 `Dexie.js` 的库来简化IndexedDB的操作。

*   **PWA核心技术：**
    1.  **Service Worker：** 一个在后台运行的脚本，它能拦截网络请求。这是实现**离线访问**的关键。当应用启动时，它可以缓存所有应用外壳（HTML, CSS, JS），让你在没有网络时也能打开应用。
    2.  **Web App Manifest：** 一个`manifest.json`文件，它告诉浏览器这个应用的名字、图标、启动画面等信息，使得浏览器能够提供“添加到主屏幕”的功能。

**这个架构的优势：**
*   **纯本地，无后端依赖：** 无需服务器、无需网络连接（初次加载后）、无需任何费用。
*   **数据隐私：** 所有卡片数据都安全地存储在你设备的浏览器中，永远不会上传到任何服务器。
*   **原生级体验：** 可以从桌面/主屏幕直接启动，拥有自己的图标和窗口，感觉就像一个真正的App。
*   **跨平台：** 一套代码，在所有支持PWA的现代浏览器上（Chrome, Edge, Firefox, Safari）都能运行。
*   **极度轻量：** 最终打包的应用体积会非常小。

---

### 2. 功能设计与界面草图 (基本不变，但交互逻辑有调整)

界面设计可以沿用之前的草图，但数据来源完全不同。

#### **数据流 (Data Flow):**

1.  **首次访问：**
    *   浏览器加载网页。
    *   Service Worker被激活，并将应用的核心文件（HTML/CSS/JS）缓存起来。
    *   应用检查IndexedDB中是否有数据。初次访问时为空。

2.  **上传卡片组：**
    *   用户点击“上传”按钮，选择一个`.md`文件。
    *   前端Svelte代码解析`.md`文件成JSON格式。
    *   使用`Dexie.js`将这个JSON对象存入IndexedDB的一个“表”（例如`decks`表）中。
    *   界面立刻响应，从IndexedDB中读出所有卡片组，并更新主面板列表。

3.  **学习卡片：**
    *   用户在主面板点击某个卡片组的“开始学习”按钮。
    *   应用根据该卡片组的ID，从IndexedDB中查询并读取对应的JSON数据。
    *   学习界面加载数据，开始学习。

4.  **后续访问（离线时）：**
    *   用户点击桌面图标启动应用。
    *   Service Worker直接从缓存中提供应用文件，实现秒开，无需网络。
    *   应用从IndexedDB中加载已有的卡片组数据，所有内容立即可用。

---

### 3. 开发路线图 (Roadmap for a Local-First PWA)

这是一个全新的、针对本地化应用的开发计划。

#### **第一阶段：项目初始化与PWA基础配置 (Week 1)**
*   **目标：** 搭建一个可以“安装”到桌面的空壳应用。
*   **任务：**
    1.  使用 `npm create svelte@latest` 初始化一个新的 **SvelteKit** 项目。
    2.  配置 **`vite-plugin-pwa`** 插件，生成`Web App Manifest`和`Service Worker`。
    3.  设计应用图标。
    4.  运行并测试“添加到主屏幕/安装应用”功能，确保能生成一个可离线访问的空应用。
    5.  引入`Dexie.js`库，并创建一个简单的数据库服务模块来初始化IndexedDB的表结构（如 `decks` 表）。

#### **第二阶段：核心UI与数据导入 (Week 2)**
*   **目标：** 实现卡片数据的导入和展示。
*   **任务：**
    1.  构建主面板（Dashboard）的UI组件，用于展示卡片组列表。
    2.  构建学习界面的UI组件（可以复用之前的HTML/CSS）。
    3.  实现文件上传功能：创建一个按钮，点击后打开文件选择器，限制选择`.md`文件。
    4.  编写`.md`文件解析器（JavaScript函数），将文件内容转换为我们定义好的JSON结构。
    5.  实现“保存到数据库”的逻辑：当文件解析成功后，调用`Dexie.js`将JSON数据写入IndexedDB。
    6.  让主面板UI动态地从IndexedDB中读取并显示所有卡片组。

#### **第三阶段：学习功能与交互逻辑 (Week 3)**
*   **目标：** 让用户能够真正地学习卡片。
*   **任务：**
    1.  实现路由功能：点击主面板的某个卡片组，能跳转到学习界面，并传递卡片组的ID。
    2.  在学习界面，根据传入的ID，从IndexedDB中加载对应的卡片数据。
    3.  实现完整的学习交互逻辑：卡片翻转、随机顺序、进度显示、“上一个/下一个”导航。
    4.  添加删除卡片组的功能：在主面板上为每个卡片组添加删除按钮，点击后从IndexedDB中移除对应条目。
    5.  (可选高级功能) 数据导出：添加一个“导出数据”按钮，将IndexedDB中的所有数据打包成一个JSON文件，让用户可以备份。

#### **第四阶段：完善与优化 (Week 4)**
*   **目标：** 打磨应用，提升用户体验。
*   **任务：**
    1.  实现夜间/日间模式切换，并将用户的选择持久化到LocalStorage中，以便下次打开时保持主题。
    2.  添加过渡动画和加载状态提示，让UI感觉更流畅。
    3.  **关键：** 测试应用的离线功能。断开网络，重新启动应用，确保所有功能（除了首次加载字体）都能正常工作。
    4.  进行全面的浏览器兼容性测试（Chrome, Edge, Safari on macOS/iOS）。
    5.  (可选高级功能) 实现间隔重复（Spaced Repetition）算法，将每张卡的复习状态（下次复习时间、难度因子等）也存入IndexedDB。


